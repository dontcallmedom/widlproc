/** 
 * Licensed to OMTP Ltd. (OMTP) under one or more contributor license agreements. 
 * See the NOTICE file distributed with this work for additional information regarding 
 * copyright ownership. 
 * 
 * The Reference Implementation (save for such parts of the reference implementation made 
 * available under separate terms and conditions) is made available under the terms of the 
 * Apache License, version 2.0, subject to the condition that any "Works" and "Derivative 
 * Works" used or distributed for commercial purposes must be and remain compliant with the
 * BONDI specification as promulgated by OMTP in each release. Your implementation of the 
 * Reference Implementation (whether object or source) must malongain these conditions, and 
 * you must notify any recipient of this condition in a conspicuous way.
 * 
 * You may not use this BONDI Reference Implementation except in compliance with the License. 
 * 
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 or at 
 * http://bondi.omtp.org/BONDI-LICENSE-2.0 
 */

/**
 * \brief Provides a persistence API to access the file system.
 *
 * api-feature http://bondi.omtp.org/api/filesystem.mount
 * \n Call to FileSystemManager.mount
 * \n Device Capability: io.file.read
 * 
 * api-feature http://bondi.omtp.org/api/filesystem.registerEventListener
 * \n Call to FileSystemManager.registerEventListener
 * \n Device Capability: io.file.read
 *
 * api-feature http://bondi.omtp.org/api/filesystem.listFiles
 * \n Call to File.listFiles
 * \n Device Capability: io.file.read
 *
 * api-feature http://bondi.omtp.org/api/filesystem.resolve
 * \n Call to File.resolve
 * \n Device Capability: io.file.read
 *
 * api-feature http://bondi.omtp.org/api/filesystem.open
 * \n Call to File.open
 * \n Device Capability: io.file.read
 * \n Device Capability: io.file.write
 * 
 * api-feature http://bondi.omtp.org/api/filesystem.copyTo
 * \n Call to File.copyTo
 * \n Device Capabilities: io.file.read for the source and io.file.write for the target
 * 
 * api-feature http://bondi.omtp.org/api/filesystem.moveTo
 * \n Call to File.moveTo
 * \n Device Capabilities: io.file.read for the source and io.file write for the target
 * 
 * api-feature http://bondi.omtp.org/api/filesystem.createDirectory
 * \n Call to File.createDirectory
 * \n Device Capability: io.file.write
 * 
 * api-feature http://bondi.omtp.org/api/filesystem.createFile
 * \n Call to File.createFile
 * \n Device Capability: io.file.write
 * 
 * api-feature http://bondi.omtp.org/api/filesystem.deleteDirectory
 * \n Call to File.deleteDirectory
 * \n Device Capability: io.file.write
 * 
 * api-feature http://bondi.omtp.org/api/filesystem.deleteFile
 * \n Call to File.deleteFile
 * \n Device Capability: io.file.write
 *
 * device-cap io.file.read
 * \n Read directory or file
 * \n      Security Parameters:
 * \n          - DOMString name:  Name of directory or file, in virtual filesystem, ie /rootname/filename
 * 
 * device-cap io.file.write
 * \n Write directory or file
 * \n      Security Parameters:
 * \n          - DOMString name:  Name of directory or file, in virtual filesystem, ie /rootname/filename
 *
 * \author Paddy Byers paddy@aplixcorp.com
 * \author Anselm R Garbe anselm@aplixcorp.com
 * \version 0.6
 */
module filesystem {

	typedef Object              Map;
	typedef Object              Date;
	typedef sequence<DOMString> StringArray;
	typedef sequence<File>      FileArray;

	[Callback] interface FileSystemSuccessCallback {
		void onSuccess(in File file);
	};

	interface FileSystemError : Error {
		const unsigned short UNKNOWN_ERROR = 0;
		const unsigned short IO_ERROR      = 1;
		readonly attribute unsigned short code;
	};

	/**
	 * \brief FileSystemManager API.
	 *
	 * This file system API provides basic filesystem access.
	 *
	 * \code
	 *    bondi.load('fs', { id: 'filesystem', success, error });
	 *
	 *    var root = fs.mount(fs.getPersistLocation());
	 *    for(var i = 0; i < root.length; i++) {
	 *    	alert(root[i].name); // displays name of each file in root directory
	 *    }
	 *    var file = root.createFile("test.txt");
	 *    var out  = file.open("w");
	 *    // writes Hello World to test.txt
	 *    out.write("Hello World", "UTF-8");
	 *    out.close();
	 * \endcode
	 */
	interface FileSystemManager {

		/**
		 * \brief Contains the implementation dependent maximum path length.
		 *
		 * This attribute is read-only.
		 *
		 * \code
		 *    fs.maxPathLength;
		 * \endcode
		 */
		readonly attribute long maxPathLength;

		/**
		 * \brief Returns a location path for the given arguments,
		 * relative to the root locations supported.
		 *
		 * This function resolves location specifiers to location paths.
		 * The following location specifiers are supported:
		 * \n "app:package" - the application package directory, this is read-only,
		 *                    this is identical to the widget directory
		 * \n "app:private" - the private storage of the current application
		 * \n "app:public"  - the public storage of the current applicaption
		 * \n "app:temp"    - the temporary storage of the current applicaption
		 * \n "documents"   - the documents location, eg resolving to "My Documents"
		 * \n "pictures"    - the pictures location, eg resolving to "My Pictures"
		 * \n "videos"      - the videos location, eg resolving to "My Videos"
		 * \n "temp"        - the temporary storage, eg resolving to "Temp"
		 *
		 * \code
		 *   var location = fs.getDefaultLocation('app:package');
		 * \endcode
		 *
		 * \param specifier - the location specifier, see above for supported specifiers.
		 * \param space     - optional, minimum required bytes for this location,
		 *                    <em>0</em> (default) means no limitation
		 * \return the persistent location as a string
		 */
		DOMString getDefaultLocation(in DOMString specifier, in long space);

		/**
		 * \brief Returns all mountable root locations.
		 *
		 * Usually the following root locations will be supported,
		 * though their physical location is implementation dependent:
		 * \n "appdata"   - this often represents the "Application Data" directory
		 * \n "documents" - this often represents the "My Documents" directory
		 * \n "pictures"  - this often represents the "My Pictures" directory
		 * \n "videos"    - this often represents the "My Videos" directory
		 * \n "temp"      - this often represents the "Temp" directory
		 *
		 * See also the getDefaultLocation method.
		 *
		 * \code
		 *   var locations = fs.getRootLocations();
		 *   for(var i = 0; i < locations.length; i++) {
		 *   	// locations[i] is a mountable root location
		 *   }
		 * \endcode
		 *
		 * \return string array of root locations.
		 */
		StringArray getRootLocations();

		/**
		 * \brief Returns all mount points currently in use.
		 *
		 * Returns all mount points currently in use by this FileSystem service
		 * instance.
		 *
		 * \code
		 *   var mounts = fs.getMountPoints();
		 *   for(var i = 0; i < mounts.length; i++) {
		 *     // mounts[i] is mounted location
		 *   }
		 * \endcode
		 *
		 * \return file array of current mount points
		 */
		FileArray getMountPoints();

		/**
		 * \brief Mounts a iystem location.
		 *
		 * Mounts the given system location and returns a file handle of this
		 * mount point on success. 
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.mount 
		 *
		 * \code
		 *    var location = fs.getDefaultLocation('temp');
		 *    var temp = fs.mount(location);
		 * \endcode
		 *
		 * \param location - the location to mount. Must be absolute in the file system.
		 * \return the mount point as a file object.
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.read permission is denied.
		 * \throw BONDIError with code INVALID_ARGUMENT if invalid location was given.
		 */
		File mount(in DOMString location)
			raises(BONDIError);

		/**
		 * \brief Unmounts the given mount point.
		 *
		 * Always succeeds.
		 *
		 * \code
		 *    fs.unmount(home);
		 * \endcode
		 *
		 * \param mountpoint - the mountpoint file handle.
		 */
		void unmount(in File mountpoint);

		/**
		 * \brief Registers a filesystem event listener.
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.registerEventListener
		 *
		 * \code
		 *   var listener = { mountEvent: function(e) { alert('mounted ' + e); },
		 *                    unmountEvent: function(e) { alert('unmounted ' + e); };
		 *   fs.registerEventListener(listener);
		 * \endcode
		 *
		 * \param listener - the listener interface implementation
		 */
		void registerEventListener(in FileSystemListener listener);

		/**
		 * \brief Unregisters a filesystem event listener.
		 *
		 * \code
		 *   fs.unregisterEventListener(listener);
		 * \endcode
		 *
		 * \param listener - the listener interface implementation
		 */
		void unregisterEventListener(in FileSystemListener listener);
	};

	/**
	 * \brief FileSystemListener API.
	 *
	 * This file system event API listens for file system events.
	 * Currently mount and unmount events only. It is supposed to be
	 * implemented in JavaScript.
	 *
	 * \code
	 *   var fsEventImpl = {
	 *   	mountEvent: function(location) {
	 *   		// location has been mounted
	 *   	},
	 *   	unmountEvent: function(location) {
	 *   		// location has been unmounted
	 *   	}
	 *   };
	 * \endcode
	 */
	interface FileSystemListener {

		/**
		 * \brief Called when a new location gets available.
		 *
		 * A new location could be a storage card for example.
		 *
		 * \param location - the newly available location
		 */
		void mountEvent(in DOMString location);

		/**
		 * \brief Called when a location gets unavailable.
		 *
		 * Such a location could be a storage card for example.
		 *
		 * \param location - the location which is becoming unavailable
		 */
		void unmountEvent(in DOMString location);
	};

	/**
	 * \brief File API.
	 *
	 * This interface represents the file abstraction.
	 *
	 * It requires that "/" is used as platform-agnostic path separator.
	 */
	interface File {

		/**
		 * \brief Parent directory handle.
		 *
		 * This attribute is read-only.
		 *
		 * <em>null</em> if there is no parent directory.
		 *
		 * \code
		 *    var parent = file.parent;
		 *    if(parent != null) {
		 *      // parent directory handle
		 *    }
		 * \endcode
		 */
		readonly attribute File parent;

		/**
		 * \brief File/directory access state.
		 *
		 * <em>false</em> if there is write access.
		 * This attribute is read-only.
		 *
		 * \code
		 *    if(file.readOnly) {
		 *      // file cannot be written
		 *    }
		 * \endcode
		 */
		readonly attribute boolean readOnly;

		/**
		 * \brief File type.
		 *
		 * <em>false</em> if the file is a directory.
		 * This attribute is read-only.
		 *
		 * \code
		 *    if(file.isFile) {
		 *      // is a file
		 *    }
		 * \endcode
		 */
		readonly attribute boolean isFile;

		/**
		 * \brief File type.
		 *
		 * <em>true</em> if the file is a directory.
		 * This attribute is read-only.
		 *
		 * \code
		 *    if(file.isDirectory) {
		 *      // is a directory
		 *    }
		 * \endcode
		 */
		readonly attribute boolean isDirectory;

		/**
		 * \brief Creation timestamp.
		 *
		 * The creation timestamp of this file.
		 * This attribute is read-only.
		 *
		 * \code
		 *    alert(file.created); // displays the creation timestamp
		 * \endcode
		 *
		 */
		readonly attribute Date created;

		/**
		 * \brief Modification timestamp.
		 *
		 * The modification timestamp of this file.
		 * This attribute is read-only.
		 *
		 * \code
		 *    alert(file.modified); // displays the modification timestamp
		 * \endcode
		 *
		 */
		readonly attribute Date modified;

		/**
		 * \brief Extension of this file.
		 *
		 * Assumed the file is called <em>foo.bar</em>, then the extension is <em>bar</em>.
		 * If this file is a directory the extension will be <em>null</em>.
		 * This attribute is read-only.
		 *
		 * \code
		 *    alert(file.extension ); // should be bar if the file is foo.bar
		 * \endcode
		 */
		readonly attribute DOMString extension;

		/**
		 * \brief Path of this file, excluding the file name.
		 *
		 * Assumed the file path is <em>/baz/blah/foo.bar</em>, then the path is <em>/baz/blah/</em>.
		 * This attribute is read-only.
		 *
		 * \code
		 *    alert(file.path); // should be /baz/blah/ if the file is /baz/blah/foo.bar
		 * \endcode
		 */
		readonly attribute DOMString path;

		/**
		 * \brief File name.
		 *
		 * Assumed the file path is <em>/baz/blah/foo.bar</em>, then the file name is <em>foo.bar</em>.
		 * This attribute is read-only.
		 *
		 * \code
		 *    alert(file.name); // should be foo.bar if the file is /baz/blah/foo.bar
		 * \endcode
		 */
		readonly attribute DOMString name;

		/**
		 * \brief Full path of this file.
		 *
		 * Assumed the file path is <em>/baz/blah/foo.bar</em>, then the file name is <em>foo.bar</em>.
		 * This attribute is read-only.
		 *
		 * \code
		 *    alert(file.fullPath); // should be foo.bar if the file is /baz/blah/foo.bar
		 * \endcode
		 */
		readonly attribute DOMString fullPath;

		/**
		 * \brief Size in bytes of this file.
		 *
		 * This attribute does not exist if this file is a directory.
		 * This attribute is read-only.
		 *
		 * \code
		 *    alert(file.fileSize); // displays the file size
		 * \endcode
		 */
		readonly attribute long fileSize;

		/**
		 * \brief Files metadata.
		 *
		 * The actual map contents are implementation dependent.
		 *
		 * \code
		 *    alert(file.metadata.author); // should display the file author
		 * \endcode
		 */
		readonly attribute Map metadata;

		/**
		 * \brief Returns list of all files of this directory.
		 *
		 * The list of files contains directories and files, it does
		 * not contain the directories "." and "..".
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.listFiles
		 *
		 * \code
		 *    var files = dir.listFiles();
		 *    for(var i = 0; i < files.length; i++) {
		 *      // files[i] iterate over all files of this directory
		 *    }
		 * \endcode
		 *
		 * \return array of contents of this directory.
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.read permission is denied 
		 * \throw FileSystemError with code IO_ERROR if this is not a directory.
		 */
		FileArray listFiles()
			raises(BONDIError, FileSystemError);

		/**
		 * \brief Opens the file in the given mode supporting the given
		 * encoding.
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.open
		 *
		 * \code
		 *    // opens file for reading
		 *    var in = file.open("r", "UTF-8");
		 * \endcode
		 *
		 * \param mode - the mode for opening a file
		 * \n  - "r" for reading
		 * \n  - "a" for appending
		 * \n  - "w" for [over]writing
		 * \param encoding - the encoding for read/write operations on the file,
		 *                   supported encodings are:
		 * \n  - "UTF-8" default encoding
		 * \n  - "ISO8859-1" latin1 encoding
		 * \return file stream handle to read/write from/to.
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.read or io.file.write permission is denied.
		 * \throw BONDIError with code INVALID_ARGUMENT if invalid mode is supplied.
		 * \throw FileSystemError with code IO_ERROR if this is not a file.
		 */
		FileStream open(in DOMString mode, in DOMString encoding)
			raises(BONDIError, FileSystemError);

		/**
		 * \brief Copies this file.
		 *
		 * The copy will be created in the given path.
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.moveTo
		 *
		 * \code
		 *    // copies this file to /temp/file.copy
		 *    var op = file.copyTo(function(copiedFile) { // copiedFile is handle of copy }, null, "/temp/file.copy", false);
		 * \endcode
		 *
		 * \param successCallback - called when the file has been copied.
		 * \param errorCallback - called if an error occured.
		 * \param filePath - the new file path, [a-Z0-9_- /]+ are allowed 
		 * \param overwrite - <em>true</em> enforces overwriting an existing file.
		 * \return pending operation handle
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw FileSystemError with code IO_ERROR if it is attempted to move to a directory.
		 * \throw FileSystemError with code IO_ERROR if overwrite is <em>false</em> and target file exists.
		 */
		BONDIPendingOperation copyTo(in FileSystemSuccessCallback successCallback, in BONDIErrorCallback errorCallback, in DOMString filePath, in boolean overwrite)
			raises(BONDIError, FileSystemError);

		/**
		 * \brief Moves this file.
		 *
		 * The file will be moved atomically to the given path. This is
		 * different to copyTo and deleting the old file, because this
		 * operation does not need extra disk space on certain platforms.
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.moveTo
		 *
		 * \code
		 *    // moves this file to /temp/file.move
		 *    var op = file.moveTo(function(movedFile) { file = movedFile; }, null, "/temp/file.move");
		 * \endcode
		 *
		 * \param successCallback - called when the file has been copied.
		 * \param errorCallback - called if an error occured.
		 * \param filePath - the new file name, [a-Z0-9_- /]+ are allowed
		 * \param overwrite - <em>true</em> enforces overwriting an existing file.
		 * \return pending operation handle
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw FileSystemError with code IO_ERROR if it is attempted to move to a directory.
		 * \throw FileSystemError with code IO_ERROR if overwrite is <em>false</em> and target file exists.
		 */
		BONDIPendingOperation moveTo(in FileSystemSuccessCallback successCallback, in BONDIErrorCallback errorCallback, in DOMString filePath, in boolean overwrite)
			raises(BONDIError, FileSystemError);

		/**
		 * \brief Creates a directory.
		 *
		 * The new directory be created as a sub-directory of this. The
		 * name is not allowed to contain "/".
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.createDirectory
		 *
		 * \code
		 *    var newDir = dir.createDirectory("newDir");
		 * \endcode
		 *
		 * \param name - the new directory name, can consist of [a-Z0-9_- ]+
		 * \return file handle of the new directory
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw FileSystemError with code IO_ERROR if this is not a directory or if a file with the same name exists.
		 */
		File createDirectory(in DOMString name)
			raises(BONDIError, FileSystemError);

		/**
		 * \brief Creates a new empty file.
		 *
		 * The new empty file is created in this directory. The
		 * name is not allowed to contain "/".
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.createFile
		 *
		 * \code
		 *    var newFile = dir.createFile("newFile");
		 * \endcode
		 *
		 * \param name - the new file name, can consist of [a-Z0-9_- ]+
		 * \return file handle of the new empty file
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw FileSystemError with code IO_ERROR if this is not a directory or if a file or directory with the same name exists.
		 */
		File createFile(in DOMString name)
			raises(BONDIError, FileSystemError);

		/**
		 * \brief Resolves an existing file or directory.
		 * 
		 * The filePath is not allowed to contain "/./" or "/../"
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.resolve
		 *
		 * \code
		 *    var hellofile = dir.resolve("hello.txt");
		 * \endcode
		 *
		 * \param filePath - the relative file/directory path to resolve.
		 * \return file handle of the file or <em>null</em> if it cannot be resolved.
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.read permission is denied.
		 * \throw FileSystemError with code IO_ERROR if this is not a directory.
		 */
		File resolve(in DOMString filePath)
			raises(BONDIError, FileSystemError);

		/**
		 * \brief Deletes this directory.
		 *
		 * Returns <em>true</em> on success.
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.deleteDirectory
		 *
		 * \code
		 *    var fullPath = dir.fullPath;
		 *    if(dir.deleteDirectory(true)) {
		 *      // subsequent accesses to dir will throw an error
		 *      alert(fullPath + ' deleted');
		 *    }
		 * \endcode
		 *
		 * \param recursive - <em>true</em> means do a recursive deletion, this
		 *                    will destroy all data recursively, use with caution.
		 * \return <em>true</em> on success
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw FileSystemError withd code IO_ERROR if this is a file.
		 */
		boolean deleteDirectory(in boolean recursive)
			raises(BONDIError, FileSystemError);

		/**
		 * \brief Deletes this file.
		 *
		 * Returns <em>true</em> on success.
		 *
		 * api-feature http://bondi.omtp.org/api/filesystem.deleteFile
		 *
		 * \code
		 *    var fullPath = dir.fullPath;
		 *    if(dir.deleteFile()) {
		 *      // subsequent accesses to dir will throw an error
		 *      alert(fullPath + ' deleted');
		 *    }
		 * \endcode
		 *
		 * \return <em>true</em> on success
		 * \throw BONDIError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw FileSystemError with code IO_ERROR if this is a directory.
		 */
		boolean deleteFile()
			raises(BONDIError, FileSystemError);
	};

	/**
	 * \brief FileStream API.
	 *
	 * A FileStream represents a handle to a File opened for read and/or write.
	 * Read and write operations are performed relative to a file pointer which
	 * represents the current position in the file.
	 * 
	 * A series of read/write methods are available that permit both binary and
	 * text to be processed. In the latter case, multiple encodings are supported.
	 *
	 */
	interface FileStream {

		/**
		 * \brief Indicates whether or not the current file pointer is at the end
		 * of the file.
		 * 
		 * <em>true</em> if the position is at the end of the current file stream.
		 *
		 * \code
		 *   if(stream.eof) {
		 *      // file has been read completely
		 *   }
		 * \endcode
		 */
		readonly attribute boolean eof;

		/**
		 * \brief Get/set current position in this stream.
		 * 
		 * The position of this stream is an offset of bytes from the start
		 * of the file stream.  When invoking an operation that reads or writes
		 * from the stream, the operation will take place from the position
		 * in the position attribute.
		 *
		 * \code
		 *   alert(stream.position); // displays current stream position
		 *   // alters current stream position to the begin of the file,
		 *   // like seek() in C
		 *   stream.position = 0;
		 * \endcode
		 * \throw FileSystemError with code IO_ERROR if invalid position was given.
		 */
		attribute long position
			raises(FileSystemError);

		/**
		 * \brief Returns the number of bytes that are available for reading from 
		 * the stream.
		 * 
		 * -1 if eof is <em>true</em>.
		 *
		 * \code
		 *   alert(stream.availble); // displays the available bytes to be read
		 * \endcode
		 */
		readonly attribute long bytesAvailable;
		
		/**
		 * \brief Closes this FileStream.
		 * 
		 * Flushes any pending buffered writes and closes the File. Always succeeds.
		 * Note that pending writes might not succeed.
		 *
		 * \code
		 *   stream.close(); // closes this stream, no subsequent access to stream allowed
		 * \endcode
		 */
		void close();
		
		/**
		 * \brief Reads the specified number of characters.
		 *
		 * Reads specified number of characters and returns them as string.
		 * The resulting string length might be shorter than charCount if eof
		 * is <em>true</em>.
		 *
		 * \code
		 *   var text = stream.read(0);
		 *   stream.close();
		 * \endcode
		 *
		 * \param charCount - number of characters being read, if
		 *                    <em>0</em> it will read as long as bytes are available.
		 * \return the result of read characters as a string.
		 */
		DOMString read(in long charCount);

		/**
		 * \brief Reads the specified number of bytes from this FileStream.
		 *
		 * \code
		 *   // reads up to 256 bytes from the stream
		 *   var raw = stream.readBytes(256);
		 *   for(var i = 0; i < raw.length; i++) {
		 *     // raw[i] contains the i-th byte of the current data chunk
		 *   }
		 * \endcode
		 *
		 * \param byteCount - number of bytes being read. Must not be <em>0</em>.
		 * \return the result of read bytes as a byte (or number) array.
		 */
		ByteArray readBytes(in long byteCount);

		/**
		 * \brief Reads the specified number of bytes from this FileStream, encoding
		 * the result in base64.
		 *
		 * \code
		 *   // reads up to 256 bytes from the stream
		 *   var base64 = stream.readBytes(256);
		 * \endcode
		 *
		 * \param byteCount - number of bytes being read. Must not be <em>0</em>.
		 * \return the result of read bytes as base64 encoding string.
		 */
		DOMString readBase64(in long byteCount);

		/**
		 * \brief Writes the specified DOMString to this FileStream.
		 *
		 * \code
		 *   var text = "Hello world";
		 *   stream.write(text);
		 * \endcode
		 *
		 * \param stringData - the actual string to be written.
		 */
		void write(in DOMString stringData);
		
		/**
		 * \brief Writes the specified bytes to this FileStream.
		 *
		 * \code
		 *   var bytes = in.readBytes(256);
		 *   out.write(bytes); // writes the bytes read from in to out
		 * \endcode
		 *
		 * \param byteData - the byte data array being written.
		 */
		void writeBytes(in ByteArray byteData);

		/**
		 * \brief Converts the specified base64 DOMString to bytes and writes the 
		 * result to this FileStream.
		 *
		 * \code
		 *   var base64 = in.readBase64(256);
		 *   out.write(base64); // writes the base64 data read from in to out
		 * \endcode
		 *
		 * \param base64Data - the base64 data being written.
		 */
		void writeBase64(in DOMString base64Data);
	};

};
