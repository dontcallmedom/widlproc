/** 
 * Licensed to OMTP Ltd. (OMTP) under one or more contributor license agreements. 
 * See the NOTICE file distributed with this work for additional information regarding 
 * copyright ownership. 
 * 
 * The Reference Implementation (save for such parts of the reference implementation made 
 * available under separate terms and conditions) is made available under the terms of the 
 * Apache License, version 2.0, subject to the condition that any "Works" and "Derivative 
 * Works" used or distributed for commercial purposes must be and remain compliant with the
 * BONDI specification as promulgated by OMTP in each release. Your implementation of the 
 * Reference Implementation (whether object or source) must maintain these conditions, and 
 * you must notify any recipient of this condition in a conspicuous way.
 * 
 * You may not use this BONDI Reference Implementation except in compliance with the License. 
 * 
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 or at 
 * http://bondi.omtp.org/BONDI-LICENSE-2.0 
 */

/**
 * \brief Provides a persistence API to access the file system.
 *
 * \def-api-feature http://bondi.omtp.org/api/filesystem.read
 * \brief Filesystem read operations, including reading directory listings,
 *        file contents and mounting root locations.
 * \device-cap io.file.read
 *
 * \def-api-feature http://bondi.omtp.org/api/filesystem.write
 * \brief Filesystem write operations, including creating files/directories,
 *        writing to files, deleting files/directories, moving and copying
 *        files.
 * \device-cap io.file.write
 *
 * \def-device-cap io.file.read
 * \brief Read directory or file
 * \param name Name of directory or file, in virtual filesystem, i.e. /rootname/filename
 *
 * \def-device-cap io.file.write
 * \brief Write directory or file
 * \param name Name of directory or file, in virtual filesystem, i.e. /rootname/filename
 *
 * \author Paddy Byers &lt;paddy@aplixcorp.com&gt;
 * \author Anselm R Garbe &lt;anselm@aplixcorp.com&gt;
 * \version 1.0
 */
module filesystem {

	/**
	 * Array of File.
	 */
	typedef sequence<File> FileArray;

	/**
	 * \brief File system specific success callback.
	 *
	 * This callback interface is specific to this filesystem API. It
	 * specifies a success callback with a function taking a File object as
	 * input argument.
	 */
	[Callback] interface FileSystemSuccessCallback {
		void onSuccess(in File file);
	};

	/**
	 * \brief FileSystemManager API.
	 *
	 * This file system API provides basic filesystem access.
	 *
	 * \code
	 * 	var dir = bondi.filesystem.mount(bondi.filesystem.getDefaultLocation("app:public"));
	 * 	var files = dir.listFiles();
	 * 	for(var i = 0; i < files.length; i++) {
	 * 		alert(files[i].name); // displays name of each file in directory
	 * 	}
	 * 	var file = dir.createFile("test.txt");
	 * 	var out  = file.open("w", "UTF-8");
	 * 	// writes Hello World to test.txt
	 * 	out.write("Hello World");
	 * 	out.close();
	 * \endcode
	 */
	interface FileSystemManager {

		/**
		 * \brief Contains the implementation dependent maximum path length.
		 *
		 * This attribute is read-only.
		 *
		 * \code
		 * 	alert(bondi.filesystem.maxPathLength);
		 * \endcode
		 */
		readonly attribute long maxPathLength;

		/**
		 * \brief Returns a location path for the given arguments,
		 * relative to the root locations supported.
		 *
		 * The location path must not represent a physical location
		 * part, it can consist of an portable identifier.
		 *
		 * This function resolves location specifiers to location paths.
		 * The following location specifiers are supported:
		 * \n "app:package" - the application package directory, this is read-only,
		 *                    this is identical to the widget directory
		 * \n "app:private" - the private storage of the current application
		 * \n "app:public"  - the public storage of the current application
		 * \n "app:temp"    - the temporary storage of the current application
		 * \n "documents"   - the documents location, e.g. resolving to "My Documents"
		 * \n "pictures"    - the pictures location, e.g. resolving to "My Pictures"
		 * \n "videos"      - the videos location, e.g. resolving to "My Videos"
		 * \n "temp"        - the temporary storage, e.g resolving to "Temp"
		 *
		 * \code
		 * 	var location = bondi.filesystem.getDefaultLocation('app:package');
		 * \endcode
		 *
		 * \param specifier - the location specifier, see above for supported specifiers.
		 * \param space     - optional, minimum required bytes for this location,
		 *                    <em>0</em> (default) means no limitation
		 * \return the location as a string or <em>null</em> if there
		 *         is no location for the given specifier or if there is not
		 *         enough space left for the requested space in bytes.
		 * \throw BONDIError with code INVALID_ARGUMENT if the
		 *        specifier or space arguments are invalid
		 */
		DOMString getDefaultLocation(in DOMString specifier, in long space)
			raises(BONDIError);

		/**
		 * \brief Returns all mountable root locations.
		 *
		 * The root locations can also be retrieved individually using
		 * the getDefaultLocation method.
		 *
		 * Usually the following root locations will be supported,
		 * though their physical location is implementation dependent:
		 * \n "appdata"   - this often represents the "Application Data" directory
		 * \n "documents" - this often represents the "My Documents" directory
		 * \n "pictures"  - this often represents the "My Pictures" directory
		 * \n "videos"    - this often represents the "My Videos" directory
		 * \n "temp"      - this often represents the "Temp" directory
		 *
		 * See also the getDefaultLocation method.
		 *
		 * \code
		 * 	var locations = bondi.filesystem.getRootLocations();
		 * 	for(var i = 0; i < locations.length; i++) {
		 * 		// locations[i] is a mountable root location
		 * 	}
		 * \endcode
		 *
		 * \return string array of root locations.
		 */
		StringArray getRootLocations();

		/**
		 * \brief Returns all mount points currently in use.
		 *
		 * Returns all mount points currently in use by this filesystem API 
		 * instance.
		 *
		 * \code
		 * 	var mounts = bondi.filesystem.getMountPoints();
		 * 	for(var i = 0; i < mounts.length; i++) {
		 * 		// mounts[i] is mounted location
		 * 	}
		 * \endcode
		 *
		 * \return file array of current mount points
		 */
		FileArray getMountPoints();

		/**
		 * \brief Mounts a system location.
		 *
		 * Mounts the given system location and returns a file handle of this
		 * mount point on success. 
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.read
		 *
		 * \code
		 * 	var location = bondi.filesystem.getDefaultLocation('temp');
		 * 	var temp = bondi.filesystem.mount(location);
		 * \endcode
		 *
		 * \param location - the location to mount. Must be absolute in the file system.
		 * \return the mount point as a file object.
		 * \throw BONDISecurityError with code PERMISSION_DENIED if io.file.read permission is denied.
		 * \throw BONDIError with code INVALID_ARGUMENT if invalid location was given.
		 */
		File mount(in DOMString location)
			raises(BONDISecurityError, BONDIError);

		/**
		 * \brief Unmounts the given mount point.
		 *
		 * \code
		 * 	bondi.filesystem.unmount(home);
		 * \endcode
		 *
		 * \param mountpoint - the mountpoint file handle.
		 * \throw BONDIError with code INVALID_ARGUMENT if the given
		 *        handle is not a mountpoint.
		 */
		void unmount(in File mountpoint)
			raises(BONDIError);

		/**
		 * \brief Registers a filesystem event listener.
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.read
		 *
		 * \code
		 * 	var listener = { mountEvent: function(e) { alert('mounted ' + e); },
		 * 	                 unmountEvent: function(e) { alert('unmounted ' + e); };
		 * 	bondi.filesystem.registerEventListener(listener);
		 * \endcode
		 *
		 * \param listener - the listener interface implementation
		 * \throw BONDIError with code INVALID_ARGUMENT if the given listener
		 *        is invalid or not a listener.
		 */
		void registerEventListener(in FileSystemListener listener)
			raises(BONDIError);

		/**
		 * \brief Unregisters a filesystem event listener.
		 *
		 * \code
		 * 	bondi.filesystem.unregisterEventListener(listener);
		 * \endcode
		 *
		 * \param listener - the listener interface implementation
		 * \throw BONDIError with code INVALID_ARGUMENT if the given listener
		 *        is invalid or not a listener.
		 */
		void unregisterEventListener(in FileSystemListener listener)
			raises(BONDIError);
	};

	/**
	 * \brief FileSystemListener API.
	 *
	 * This file system event API listens for file system events.
	 * Currently mount and unmount events only. It is supposed to be
	 * implemented in JavaScript.
	 *
	 * \code
	 * 	var fsEventImpl = {
	 * 		mountEvent: function(location) {
	 * 		// location has been mounted
	 * 		},
	 * 		unmountEvent: function(location) {
	 * 			// location has been unmounted
	 * 		}
	 * 	};
	 * \endcode
	 */
	interface FileSystemListener {

		/**
		 * \brief Called when a new location gets available.
		 *
		 * A new location could be a storage card for example.
		 *
		 * \param location - the newly available location
		 */
		void mountEvent(in DOMString location);

		/**
		 * \brief Called when a location gets unavailable.
		 *
		 * Such a location could be a storage card for example.
		 *
		 * \param location - the location which is becoming unavailable
		 */
		void unmountEvent(in DOMString location);
	};

	/**
	 * \brief File API.
	 *
	 * This interface represents the file abstraction.
	 *
	 * It requires that "/" is used as platform-agnostic path separator.
	 *
	 * \code
	 * 	var file = dir.createFile("test.txt");
	 * 	var out  = file.open("w", "UTF-8");
	 * 	// writes Hello World to test.txt
	 * 	out.write("Hello World");
	 * 	out.close();
	 * \endcode
	 */
	interface File {

		/**
		 * \brief Parent directory handle.
		 *
		 * This attribute is read-only.
		 *
		 * <em>null</em> if there is no parent directory.
		 *
		 * If there is no parent directory, this file is a mount point.
		 *
		 * \code
		 * 	var parent = file.parent;
		 * 	if(parent != null) {
		 * 		// parent directory handle
		 * 	}
		 * \endcode
		 */
		readonly attribute File parent;

		/**
		 * \brief File/directory access state.
		 *
		 * <em>false</em> if there is write access.
		 * This attribute is read-only.
		 *
		 * This attribute represents the actual state of a
		 * file/directory in the filesystem. It does not check if the
		 * accessor has io.file.write permission.
		 *
		 * \code
		 * 	if(file.readOnly) {
		 * 		// file cannot be written
		 * 	}
		 * \endcode
		 */
		readonly attribute boolean readOnly;

		/**
		 * \brief File type.
		 *
		 * <em>false</em> if the file is a directory.
		 * This attribute is read-only.
		 *
		 * \code
		 * 	if(file.isFile) {
		 * 		// is a file
		 * 	}
		 * \endcode
		 */
		readonly attribute boolean isFile;

		/**
		 * \brief File type.
		 *
		 * <em>true</em> if the file is a directory.
		 * This attribute is read-only.
		 *
		 * \code
		 * 	if(file.isDirectory) {
		 * 		// is a directory
		 * 	}
		 * \endcode
		 */
		readonly attribute boolean isDirectory;

		/**
		 * \brief Creation timestamp.
		 *
		 * The creation timestamp of this file.
		 * This attribute is read-only.
		 *
		 * \code
		 * 	alert(file.created); // displays the creation timestamp
		 * \endcode
		 *
		 */
		readonly attribute Date created;

		/**
		 * \brief Modification timestamp.
		 *
		 * The modification timestamp of this file.
		 * This attribute is read-only.
		 *
		 * \code
		 * 	alert(file.modified); // displays the modification timestamp
		 * \endcode
		 *
		 */
		readonly attribute Date modified;

		/**
		 * \brief Extension of this file.
		 *
		 * Assumed the file is called <em>foo.bar</em>, then the extension is <em>bar</em>.
		 * If this file is a directory the extension will be <em>null</em>.
		 * This attribute is read-only.
		 *
		 * \code
		 * 	alert(file.extension ); // should be bar if the file is foo.bar
		 * \endcode
		 */
		readonly attribute DOMString extension;

		/**
		 * \brief Path of this file, excluding the file name.
		 *
		 * Assumed the file path is <em>/baz/blah/foo.bar</em>, then the path is <em>/baz/blah/</em>.
		 * This attribute is read-only.
		 *
		 * \code
		 * 	alert(file.path); // should be /baz/blah/ if the file is /baz/blah/foo.bar
		 * \endcode
		 */
		readonly attribute DOMString path;

		/**
		 * \brief File name.
		 *
		 * Assumed the file path is <em>/baz/blah/foo.bar</em>, then the file name is <em>foo.bar</em>.
		 * This attribute is read-only.
		 *
		 * \code
		 * 	alert(file.name); // should be foo.bar if the file is /baz/blah/foo.bar
		 * \endcode
		 */
		readonly attribute DOMString name;

		/**
		 * \brief Full path of this file.
		 *
		 * Assumed the file path is <em>/baz/blah/foo.bar</em>, then the file name is <em>foo.bar</em>.
		 * This attribute is read-only.
		 *
		 * \code
		 * 	alert(file.fullPath); // should be foo.bar if the file is /baz/blah/foo.bar
		 * \endcode
		 */
		readonly attribute DOMString fullPath;

		/**
		 * \brief Size in bytes of this file.
		 *
		 * This attribute is read-only.
		 *
		 * If it is attempted to read this attribute on a directory,
		 * <em>undefined</em> is returned.
		 *
		 * \code
		 * 	alert(file.fileSize); // displays the file size
		 * \endcode
		 */
		readonly attribute long fileSize;

		/**
		 * \brief Files metadata.
		 *
		 * The actual map contents are implementation dependent.
		 *
		 * \code
		 * 	alert(file.metadata.author); // should display the file author
		 * \endcode
		 */
		readonly attribute Map metadata;

		/**
		 * \brief Returns list of all files of this directory.
		 *
		 * The list of files contains directories and files, it does
		 * not contain the directories "." and "..".
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.read
		 *
		 * \code
		 * 	var files = dir.listFiles();
		 * 	for(var i = 0; i < files.length; i++) {
		 * 		// files[i] iterate over all files of this directory
		 * 	}
		 * \endcode
		 *
		 * \return array of contents of this directory.
		 * \throw BONDISecurityError with code PERMISSION_DENIED if io.file.read permission is denied 
		 * \throw BONDIError with code IO_ERROR if this is not a directory.
		 */
		FileArray listFiles()
			raises(BONDISecurityError, BONDIError);

		/**
		 * \brief Opens the file in the given mode supporting the given
		 * encoding.
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.read if opened for reading.
		 * \api-feature http://bondi.omtp.org/api/filesystem.write if opened for writing.
		 *
		 * \code
		 * 	// opens file for reading
		 * 	var in = file.open("r", "UTF-8");
		 * \endcode
		 *
		 * \param mode - the mode for opening a file
		 * \n  - "r" for reading
		 * \n  - "a" for appending
		 * \n  - "w" for [over]writing
		 * \param encoding - the encoding for read/write operations on the file,
		 *                   supported encodings are:
		 * \n  - "UTF-8" default encoding
		 * \n  - "ISO8859-1" latin1 encoding
		 * \return file stream handle to read/write from/to.
		 * \throw BONDISecurityError with code PERMISSION_DENIED if io.file.read or io.file.write permission is denied.
		 * \throw BONDIError with code INVALID_ARGUMENT if invalid mode
		 *        or unsupported encoding is supplied.
		 * \throw BONDIError with code IO_ERROR if this is not a file.
		 */
		FileStream open(in DOMString mode, in DOMString encoding)
			raises(BONDISecurityError, BONDIError);

		//
		// \brief Copies this file.
		//
		// The copy will be created in the given path. If this function
		// fails and the error callback is called, it will pass an
		// BONDIError with code IO_ERROR to the callback.
		//
		// \api-feature http://bondi.omtp.org/api/filesystem.write
		//
		// \code
		// 	// copies this file to /temp/file.copy
		// 	var op = file.copyTo(function(copiedFile) { /* XXX */ }, null, "/temp/file.copy", false);
		// \endcode
		//
		// \param successCallback - called when the file has been copied.
		// \param errorCallback - called if an error occured.
		// \param filePath - the new file path, [a-Z0-9_- /]+ are allowed 
		// \param overwrite - <em>true</em> enforces overwriting an existing file.
		// \return pending operation handle
		// \throw BONDISecurityError with code PERMISSION_DENIED if io.file.write permission is denied.
		// \throw BONDIError with code IO_ERROR if it is attempted to move to a directory.
		// \throw BONDIError with code IO_ERROR if overwrite is <em>false</em> and target file exists.
		//
		BONDIPendingOperation copyTo(in FileSystemSuccessCallback successCallback,
		                             in BONDIErrorCallback errorCallback,
		                             in DOMString filePath,
		                             in boolean overwrite)
			raises(BONDISecurityError, BONDIError);

		/**
		 * \brief Moves this file.
		 *
		 * The file will be moved atomically to the given path. This is
		 * different to copyTo and deleting the old file, because this
		 * operation does not need extra disk space on certain platforms.
		 * If this function fails and the error callback is called, it
		 * will pass an BONDIError with code IO_ERROR to the callback.
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.write
		 *
		 * \code
		 * 	// moves this file to /temp/file.move
		 * 	var op = file.moveTo(function(movedFile) { file = movedFile; }, null, "/temp/file.move");
		 * \endcode
		 *
		 * \param successCallback - called when the file has been copied.
		 * \param errorCallback - called if an error occured.
		 * \param filePath - the new file name, [a-Z0-9_- /]+ are allowed
		 * \param overwrite - <em>true</em> enforces overwriting an existing file.
		 * \return pending operation handle
		 * \throw BONDISecurityError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw BONDIError with code IO_ERROR if it is attempted to move to a directory.
		 * \throw BONDIError with code IO_ERROR if overwrite is <em>false</em> and target file exists.
		 */
		BONDIPendingOperation moveTo(in FileSystemSuccessCallback successCallback,
		                             in BONDIErrorCallback errorCallback,
		                             in DOMString filePath,
		                             in boolean overwrite)
			raises(BONDISecurityError, BONDIError);

		/**
		 * \brief Creates a directory.
		 *
		 * The new directory be created as a sub-directory of this. The
		 * name is not allowed to contain "/".
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.write
		 *
		 * \code
		 * 	var newDir = dir.createDirectory("newDir");
		 * \endcode
		 *
		 * \param name - the new directory name, can consist of [a-Z0-9_- ]+
		 * \return file handle of the new directory
		 * \throw BONDISecurityError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw BONDIError with code IO_ERROR if this is not a directory or if a file with the same name exists.
		 */
		File createDirectory(in DOMString name)
			raises(BONDISecurityError, BONDIError);

		/**
		 * \brief Creates a new empty file.
		 *
		 * The new empty file is created in this directory. The
		 * name is not allowed to contain "/".
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.write
		 *
		 * \code
		 * 	var newFile = dir.createFile("newFile");
		 * \endcode
		 *
		 * \param name - the new file name, can consist of [a-Z0-9_- ]+
		 * \return file handle of the new empty file
		 * \throw BONDISecurityError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw BONDIError with code IO_ERROR if this is not a directory or if a file or directory with the same name exists.
		 */
		File createFile(in DOMString name)
			raises(BONDISecurityError, BONDIError);

		/**
		 * \brief Resolves an existing file or directory.
		 * 
		 * The filePath is not allowed to contain "/./" or "/../"
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.read
		 *
		 * \code
		 * 	var hellofile = dir.resolve("hello.txt");
		 * \endcode
		 *
		 * \param filePath - the relative file/directory path to resolve.
		 * \return file handle of the file or <em>null</em> if it cannot be resolved.
		 * \throw BONDISecurityError with code PERMISSION_DENIED if io.file.read permission is denied.
		 * \throw BONDIError with code IO_ERROR if this is not a directory.
		 */
		File resolve(in DOMString filePath)
			raises(BONDISecurityError, BONDIError);

		/**
		 * \brief Deletes this directory.
		 *
		 * Returns <em>true</em> on success.
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.write
		 *
		 * \code
		 * 	var fullPath = dir.fullPath;
		 * 	if(dir.deleteDirectory(true)) {
		 * 		// subsequent accesses to dir will throw an error
		 * 		alert(fullPath + ' deleted');
		 * 	}
		 * \endcode
		 *
		 * \param recursive - <em>true</em> means do a recursive deletion, this
		 *                    will destroy all data recursively, use with caution.
		 * \return <em>true</em> on success
		 * \throw BONDISecurityError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw BONDIError withd code IO_ERROR if this is a file.
		 */
		boolean deleteDirectory(in boolean recursive)
			raises(BONDISecurityError, BONDIError);

		/**
		 * \brief Deletes this file.
		 *
		 * Returns <em>true</em> on success.
		 *
		 * \api-feature http://bondi.omtp.org/api/filesystem.write
		 *
		 * \code
		 * 	var fullPath = dir.fullPath;
		 * 	if(dir.deleteFile()) {
		 * 		// subsequent accesses to dir will throw an error
		 * 		alert(fullPath + ' deleted');
		 * 	}
		 * \endcode
		 *
		 * \return <em>true</em> on success
		 * \throw BONDISecurityError with code PERMISSION_DENIED if io.file.write permission is denied.
		 * \throw BONDIError with code IO_ERROR if this is a directory.
		 */
		boolean deleteFile()
			raises(BONDISecurityError, BONDIError);
	};

	/**
	 * \brief FileStream API.
	 *
	 * A FileStream represents a handle to a File opened for read and/or write.
	 * Read and write operations are performed relative to a file pointer which
	 * represents the current position in the file.
	 * 
	 * A series of read/write methods are available that permit both binary and
	 * text to be processed. In the latter case, multiple encodings are supported.
	 *
	 * Once a file stream is closed, any operation attempted on this stream
	 * will result in a normal JavaScript error.
	 *
	 */
	interface FileStream {

		/**
		 * \brief Indicates whether or not the current file pointer is at the end
		 * of the file.
		 * 
		 * <em>true</em> if the position is at the end of the current file stream.
		 *
		 * \code
		 * 	if(stream.eof) {
		 * 		// file has been read completely
		 * 	}
		 * \endcode
		 */
		readonly attribute boolean eof;

		/**
		 * \brief Get/set current position in this stream.
		 * 
		 * The position of this stream is an offset of bytes from the start
		 * of the file stream.  When invoking an operation that reads or writes
		 * from the stream, the operation will take place from the position
		 * in the position attribute.
		 *
		 * \code
		 * 	alert(stream.position); // displays current stream position
		 * 	// alters current stream position to the begin of the file,
		 * 	// like seek() in C
		 * 	stream.position = 0;
		 * \endcode
		 * \throw BONDIError with code IO_ERROR if invalid position was given.
		 */
		attribute long position
			setraises(BONDIError);

		/**
		 * \brief Returns the number of bytes that are available for reading from 
		 * the stream.
		 * 
		 * -1 if eof is <em>true</em>.
		 *
		 * \code
		 * 	alert(stream.bytesAvailable); // displays the available bytes to be read
		 * \endcode
		 */
		readonly attribute long bytesAvailable;

		/**
		 * \brief Closes this FileStream.
		 * 
		 * Flushes any pending buffered writes and closes the File. Always succeeds.
		 * Note that pending writes might not succeed.
		 *
		 * \code
		 * 	stream.close(); // closes this stream, no subsequent access to stream allowed
		 * \endcode
		 */
		void close();

		/**
		 * \brief Reads the specified number of characters.
		 *
		 * Reads specified number of characters and returns them as string.
		 * The resulting string length might be shorter than charCount if eof
		 * is <em>true</em>.
		 *
		 * \code
		 * 	var text = stream.read(0);
		 * 	stream.close();
		 * \endcode
		 *
		 * \param charCount - number of characters being read, if
		 *                    <em>0</em> it will read as long as bytes are available.
		 * \return the result of read characters as a string.
		 */
		DOMString read(in long charCount);

		/**
		 * \brief Reads the specified number of bytes from this FileStream.
		 *
		 * \code
		 * 	// reads up to 256 bytes from the stream
		 * 	var raw = stream.readBytes(256);
		 * 	for(var i = 0; i < raw.length; i++) {
		 * 		// raw[i] contains the i-th byte of the current data chunk
		 * 	}
		 * \endcode
		 *
		 * \param byteCount - number of bytes being read. Must not be <em>0</em>.
		 * \return the result of read bytes as a byte (or number) array.
		 */
		ByteArray readBytes(in long byteCount);

		/**
		 * \brief Reads the specified number of bytes from this FileStream, encoding
		 * the result in base64.
		 *
		 * \code
		 * 	// reads up to 256 bytes from the stream
		 * 	var base64 = stream.readBase64(256);
		 * \endcode
		 *
		 * \param byteCount - number of bytes being read. Must not be <em>0</em>.
		 * \return the result of read bytes as base64 encoding string.
		 */
		DOMString readBase64(in long byteCount);

		/**
		 * \brief Writes the specified DOMString to this FileStream.
		 *
		 * \code
		 * 	var text = "Hello world";
		 * 	stream.write(text);
		 * \endcode
		 *
		 * \param stringData - the actual string to be written.
		 */
		void write(in DOMString stringData);

		/**
		 * \brief Writes the specified bytes to this FileStream.
		 *
		 * \code
		 * 	var bytes = in.readBytes(256);
		 * 	out.writeBytes(bytes); // writes the bytes read from in to out
		 * \endcode
		 *
		 * \param byteData - the byte data array being written.
		 */
		void writeBytes(in ByteArray byteData);

		/**
		 * \brief Converts the specified base64 DOMString to bytes and writes the 
		 * result to this FileStream.
		 *
		 * \code
		 * 	var base64 = in.readBase64(256);
		 * 	out.writeBase64(base64); // writes the base64 data read from in to out
		 * \endcode
		 *
		 * \param base64Data - the base64 data being written.
		 */
		void writeBase64(in DOMString base64Data);
	};

};
